# If I had an Ink Ribbon, I could save my progress...

from __future__ import annotations

from typing import List

from fates import (
    IRProgram,
    IRFunction,
    IRInstr,
    IR_OwLiteral,
    IR_MvVar,
    IR_Assign,
    IR_Return,
    IRLiteral,
    IRVarRef,
)


# ----------------------------------------------------
# Helpers
# ----------------------------------------------------

def _c_of_operand(op: IRLiteral | IRVarRef) -> str:
    """Converts an IR operand to C code."""
    if isinstance(op, IRLiteral):
        return str(op.value)
    elif isinstance(op, IRVarRef):
        return op.name
    else:
        raise TypeError(f"Unknown operand type in IR: {op!r}")


# ----------------------------------------------------
# Instruction lowering
# ----------------------------------------------------

def _lower_instr(instr: IRInstr) -> str:
    """
    Converts a single IR instruction into C code.
    The behavior is 1:1, completely faithful to the IR.
    """

    if isinstance(instr, IR_OwLiteral):
        # target = literal;
        return f"{instr.target} = {instr.value.value};"

    if isinstance(instr, IR_MvVar):
        # target = source; // When we move in IR, we move in C as well
        return f"{instr.target} = {instr.source};"

    if isinstance(instr, IR_Assign):
        return f"{instr.target} = {_c_of_operand(instr.operand)};"

    if isinstance(instr, IR_Return):
        return f"return {_c_of_operand(instr.operand)};"

    raise TypeError(f"Unknown instruction type: {instr!r}")


# ----------------------------------------------------
# Function lowering
# ----------------------------------------------------

def _lower_function(fn: IRFunction) -> str:
    """
    Generates C for a function.
    The function is mapped directly to:

        int fn_name() {
            int a;
            int b;
            ...
            <instrs...>
        }

    The data types are maintained but kept simple: everything becomes 'int' for now,
    since Fates still only represents i32.
    """

    # Header
    out: List[str] = []
    out.append(f"int {fn.name}() {{")

    # Declaration of local variables
    for local in fn.locals:
        out.append(f"    int {local};")

    # Body of the function
    for instr in fn.instrs:
        c_line = _lower_instr(instr)
        out.append(f"    {c_line}")

    out.append("}")
    return "\n".join(out)


# ----------------------------------------------------
# Program lowering
# ----------------------------------------------------

def generate_c_program(prog: IRProgram) -> str:
    """
    Generates a complete C file from IR.
    """

    out: List[str] = []
    out.append("// Generated by Cerberus Typewriter")
    out.append("#include <stdio.h>")
    out.append("")

    for fn in prog.functions:
        out.append(_lower_function(fn))
        out.append("")  # blank line between functions

    return "\n".join(out)
