# If I had an Ink Ribbon, I could save my progress...

from __future__ import annotations

from typing import List

from fates import (
    IRProgram,
    IRFunction,
    IRInstr,
    IR_OwLiteral,
    IR_MvVar,
    IR_Assign,
    IR_Return,
    IRLiteral,
    IRVarRef,
    IR_Drop,
    IR_BlockStart,
    IR_BlockEnd,
)


# ----------------------------------------------------
# Indentation Context
# ----------------------------------------------------

class IndentContext:
    def __init__(self, initial_level: int = 1):
        # Level 1 corresponds to the indentation within the body of the C function
        self.level = initial_level
        self.size = 4

    def get_indent(self) -> str:
        return ' ' * (self.level * self.size)

    def push(self) -> None:
        self.level += 1

    def pop(self) -> None:
        self.level -= 1


# ----------------------------------------------------
# Instruction lowering
# ----------------------------------------------------
def _c_of_operand(op: IRLiteral | IRVarRef) -> str:
    """Converts an IR operand to C code."""
    if isinstance(op, IRLiteral):
        return str(op.value)
    elif isinstance(op, IRVarRef):
        return op.name
    else:
        raise TypeError(f"Unknown operand type in IR: {op!r}")


def _lower_instr(instr: IRInstr, ctx: IndentContext) -> str:
    """
    Converts a single IR instruction into C code, using the context
    to handle indentation for blocks.
    """

    # --- Block Control ---
    if isinstance(instr, IR_BlockStart):
        # Opens the block at the current indentation level
        # and increases the level for the block contents
        out = "{"
        ctx.push()
        return out

    if isinstance(instr, IR_BlockEnd):
        # Decreases the indentation level before closing the block
        ctx.pop()
        return "}"

    # --- Body Instructions ---
    # Adds indentation for all code instructions
    indent = ctx.get_indent()

    if isinstance(instr, IR_OwLiteral):
        return f"{indent}{instr.target} = {instr.value.value};"

    if isinstance(instr, IR_MvVar):
        return f"{indent}{instr.target} = {instr.source};"

    if isinstance(instr, IR_Assign):
        return f"{indent}{instr.target} = {_c_of_operand(instr.operand)};"

    if isinstance(instr, IR_Return):
        # Return statements should not be indented differently even if they
        # are the last instruction at the lowest level (function level 1);
        # the indentation logic already handles this correctly.
        return f"{indent}return {_c_of_operand(instr.operand)};"

    if isinstance(instr, IR_Drop):
        # Translates drop into a comment
        return f"{indent}/* drop {instr.target}; (out of scope) */"

    raise TypeError(f"Unknown instruction type: {instr!r}")


# ----------------------------------------------------
# Function lowering
# ----------------------------------------------------

def _lower_function(fn: IRFunction) -> str:
    out: List[str] = []
    out.append(f"int {fn.name}() {{")

    # Local variable declarations (all hoisted outside of C block scopes)
    for local in fn.locals:
        out.append(f"    int {local};")

    out.append("")

    # Function body with indentation context.
    # Initial indentation level is 1 (the '    ' right after 'int fn() {')
    ctx = IndentContext(initial_level=1)

    for instr in fn.instrs:
        c_line = _lower_instr(instr, ctx)

        # Closing '}' and opening '{' blocks are handled
        # with correct indentation inside _lower_instr.

        # Only instructions that are not block open/close
        # need the initial indentation here.
        # Otherwise, IR_BlockEnd will generate '    }'
        # and IR_BlockStart will generate '{' without leading spaces.

        if isinstance(instr, (IR_BlockStart, IR_BlockEnd)):
            # For braces, the instruction itself returns the final indentation.
            out.append(ctx.get_indent() + c_line)
        else:
            # For other instructions, _lower_instr already applied indentation.
            out.append(c_line)

    out.append("}")
    return "\n".join(out)

# ----------------------------------------------------
# Program lowering
# ----------------------------------------------------

def generate_c_program(prog: IRProgram) -> str:
    """
    Generates a complete C file from IR.
    """

    out: List[str] = []
    out.append("// Generated by Cerberus Typewriter")
    out.append("#include <stdio.h>")
    out.append("")

    for fn in prog.functions:
        out.append(_lower_function(fn))
        out.append("")  # blank line between functions

    return "\n".join(out)
